<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Side Project - Probability Monitor</title>
  <link rel="icon" type="image/png" href="public/favicon.png">
  <style>

    /* Load Unifont for multi-language support */
    @font-face {
      font-family: 'Unifont';
      src: url('public/unifont.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: "Unifont", "Menlo", "Monaco", "Consolas", monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      user-select: none;
    }

    #current-token {
      font-size: 20vw;
      font-weight: bold;
      letter-spacing: -0.05em;
      min-height: 25vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.05s;
      white-space: pre;
    }


    #candidates {
      position: fixed;
      bottom: 40px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 24px;
      font-size: 14px;
      opacity: 0.5;
    }

    .candidate {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .candidate-token {
      font-weight: bold;
      white-space: pre;
    }

    .candidate-prob {
      font-size: 10px;
      opacity: 0.7;
    }

    #status {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 10px;
      opacity: 0.3;
      display: none;
    }

    #meta {
      position: fixed;
      top: 20px;
      right: 20px;
      font-size: 10px;
      opacity: 0.5;
    }


    /* Color invert effect for reset */
    body.inverted {
      background: #fff;
      color: #000;
    }
  </style>
</head>
<body>
  <div id="status">WAITING...</div>
  <div id="meta">TEMP -- | CTX --</div>
  <div id="current-token"></div>
  <div id="candidates"></div>

  <script>
    // Elements
    const tokenDisplay = document.getElementById('current-token');
    const candidatesDisplay = document.getElementById('candidates');
    const statusDisplay = document.getElementById('status');
    const metaDisplay = document.getElementById('meta');
    // BroadcastChannel for syncing with main
    const channel = new BroadcastChannel('sideproject');

    // Timing
    let lastTokenTime = 0;
    let estimatedInterval = 100; // Initial estimate (ms)

    // Queue for incoming data
    const dataQueue = [];
    let isAnimating = false;
    let streamVersion = 0;

    // Opacity levels for candidates (index 0 = highest prob, index 4 = lowest prob)
    const OPACITY_LEVELS = [0.9, 0.7, 0.5, 0.4, 0.3];

    // Render candidates list
    function renderCandidates(candidates) {
      if (!candidates || candidates.length === 0) {
        candidatesDisplay.innerHTML = '';
        return;
      }
      
      candidatesDisplay.innerHTML = candidates.map((c, i) => `
        <div class="candidate" style="opacity: ${OPACITY_LEVELS[i] || 0.3}">
          <span class="candidate-token">${escapeHtml(formatToken(c.token))}</span>
          <span class="candidate-prob">${(c.prob * 100).toFixed(1)}%</span>
        </div>
      `).join('');
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Make whitespace tokens visible and keep layout stable
    function formatToken(token) {
      if (token === null || token === undefined) return '·';
      if (token.length === 0) return '·';
      const normalized = token.replace(/\n/g, '·');
      if (/^\s+$/.test(normalized)) {
        return normalized.replace(/\s/g, '·');
      }
      return normalized;
    }

    function formatProb(prob) {
      if (typeof prob !== 'number' || Number.isNaN(prob)) return '';
      return `${(prob * 100).toFixed(2)}%`;
    }

    function updateMeta(temp, context, delay) {
      const tempText = typeof temp === 'number' ? temp.toFixed(2) : '--';
      const ctxText = Number.isFinite(context) ? context : '--';
      const delayText = typeof delay === 'number' ? `${Math.round(delay * 1000)}ms` : '--';
      metaDisplay.textContent = `TEMP ${tempText} | CTX ${ctxText} | DELAY ${delayText}`;
    }

    // Animate flicker effect: low prob → high prob → final
    async function animateToken(data, availableTime, version) {
      const { text, candidates, final_prob } = data;
      if (version !== streamVersion) return;

      const finalCandidate = {
        token: text || '·',
        prob: typeof final_prob === 'number' ? final_prob : 0,
      };

      const dedupedCandidates = Array.isArray(candidates)
        ? candidates.filter((c) => c && c.token !== text)
        : [];

      const displayCandidates = [finalCandidate, ...dedupedCandidates].slice(0, 5);
      
      if (!displayCandidates || displayCandidates.length === 0) {
        // No candidates, just show the token
        tokenDisplay.textContent = formatToken(text);
        tokenDisplay.style.opacity = 1;
        return;
      }

      // Render candidates list
      renderCandidates(displayCandidates);

      // Sort candidates: lowest prob first (reverse order)
      const sortedCandidates = [...displayCandidates].reverse();
      const numSteps = sortedCandidates.length + 1; // +1 for final token
      const stepDuration = Math.max(20, Math.floor(availableTime * 0.8 / numSteps));

      // Flicker from lowest prob to highest prob
      for (let i = 0; i < sortedCandidates.length; i++) {
        if (version !== streamVersion) return;
        const candidate = sortedCandidates[i];
        // Opacity: lower prob = dimmer (i=0 is lowest prob)
        const opacity = OPACITY_LEVELS[sortedCandidates.length - 1 - i] || 0.3;
        
        tokenDisplay.textContent = formatToken(candidate.token);
        tokenDisplay.style.opacity = opacity;
        await sleep(stepDuration);
      }

      // Settle on final token
      if (version !== streamVersion) return;
      tokenDisplay.textContent = formatToken(text);
      tokenDisplay.style.opacity = 1;
    }

    // Process queue
    async function processQueue() {
      if (isAnimating || dataQueue.length === 0) return;
      
      isAnimating = true;
      const version = streamVersion;
      
      while (dataQueue.length > 0) {
        if (version !== streamVersion) break;
        const data = dataQueue.shift();
        // Use estimated interval, but cap at reasonable range
        const availableTime = Math.max(50, Math.min(500, estimatedInterval));
        await animateToken(data, availableTime, version);
      }
      
      isAnimating = false;
    }

    // Sleep helper
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Color invert effect
    function flashInvert() {
      document.body.classList.add('inverted');
      setTimeout(() => {
        document.body.classList.remove('inverted');
      }, 150);
    }

    // Listen for messages
    channel.onmessage = (event) => {
      const data = event.data;

      // Handle reset signal
      if (data.type === 'reset') {
        flashInvert();
        streamVersion += 1;
        dataQueue.length = 0; // Clear queue
        tokenDisplay.textContent = '?';
        candidatesDisplay.innerHTML = '';
        lastTokenTime = 0;
        updateMeta(data.temp, data.context, data.delay);
        return;
      }

      // Handle token data
      const now = performance.now();
      
      // Update timing estimate
      if (lastTokenTime > 0) {
        const interval = now - lastTokenTime;
        // Smooth the estimate
        estimatedInterval = estimatedInterval * 0.7 + interval * 0.3;
      }
      lastTokenTime = now;
      
      statusDisplay.textContent = `RECEIVING... (${Math.round(estimatedInterval)}ms)`;
      dataQueue.push(data);
      processQueue();
    };

    // Initial state
    tokenDisplay.textContent = '?';
    updateMeta();
  </script>
</body>
</html>
